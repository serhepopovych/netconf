# Configuration file is used to overwrite default variables
# values in library named exacly same as @this configuration
# file except '.cfg' extension replaced with '.sh'.
#
# File is sourced automatically by crt1.sh bootstrap code sourced
# from library. Any library MUST source at least crt1.sh.

##
## IFB
##

# Usage: netconf_ifb_help
netconf_ifb_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

IFB
===

Managing runtime configuration
------------------------------

To bring configured "ifb" device(s) (e.g. "ifb0") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up ifb ifb0
  root$ @target@/netctl/bin/netconf down ifb ifb0

To show "ifb" related configurations use:

  root$ @target@/netctl/bin/netconf show ifb ifb0

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/ifb/ifb0 <<'EOF'
# Intermediate Functional Block network device
ifb_ifb0="ifb0 type ifb"

# Add HTB as root qdisc with pfifo classless qdisc attached to default class
ifb_ifb0_ref1="qdisc+ifb0 root handle 1: htb default 0 direct_qlen 1000 r2q 10"
ifb_ifb0_ref2="class+ifb0 root classid 1:0 htb rate 10000000kbit burst 5000kb \
quantum 200000"
ifb_ifb0_ref3="qdisc+ifb0 parent 1:0 pfifo limit 1000"

# Add HTB leaf class with pfifo classless qdisc attached to it
ifb_ifb0_ref5="class+ifb0 root classid 1:1 htb rate 10000kbit burst 5kb \
quantum 1250"
ifb_ifb0_ref6="qdisc+ifb0 parent 1:1 pfifo limit 1000"
EOF

See help output from below commands for more information about this
example setup:

  # this help message
  root$ @target@/netctl/bin/netconf help vrf
  root$ @target@/netctl/bin/netconf help bridge
  root$ @target@/netctl/bin/netconf help bond
  root$ @target@/netctl/bin/netconf help host
  root$ @target@/netctl/bin/netconf help vlan
  root$ @target@/netctl/bin/netconf help route

Create Intermediate Functional Block network device that act's as traffic
mirroring or redirecting device permitting to make ingress traffic appear
as egress for traffic control queueing disciplines.

Add HTB qdisc with default class configured with pfifo classless qdisc
and leaf class with pfifo that will receive traffic from br0.1000.1 and
br0.1000.2 so they share common rate limit of 10000kbit.

_EOF
}

##
## VRF
##

# Usage: netconf_vrf_help
netconf_vrf_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

VRF
===

Managing runtime configuration
------------------------------

To bring configured "vrf" device (e.g. "red") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up vrf red
  root$ @target@/netctl/bin/netconf down vrf red

To show "vrf" related configurations use:

  root$ @target@/netctl/bin/netconf show vrf red

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/vrf/red <<'EOF'
# Create VRF "red" device and attach it to routing table 100
vrf_red="red type vrf table 100"

# This acts as address assigned on "lo" interface in outside of VRF
vrf_red_ref4="red:0 203.0.113.254/24 broadcast +"
vrf_red_ref6="red:1 2001:db8::203:0:113:254/64"
EOF

See help output from below commands for more information about this
example setup:

  root$ @target@/netctl/bin/netconf help ifb
  # this help message
  root$ @target@/netctl/bin/netconf help bridge
  root$ @target@/netctl/bin/netconf help bond
  root$ @target@/netctl/bin/netconf help host
  root$ @target@/netctl/bin/netconf help vlan
  root$ @target@/netctl/bin/netconf help route

In Linux VRFs implemented as master network device like bridge or
bonding and called l3mdev.

Enslaving to that device associates all L3 information from enslaved device
with given VRF and puts routes into VRF routing table instead of "main".

_EOF
}

##
## BRIDGE
##

# Usage: netconf_bridge_help
netconf_bridge_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

BRIDGE
======

Managing runtime configuration
------------------------------

To bring configured "bridge" device (e.g. "br0") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up bridge br0
  root$ @target@/netctl/bin/netconf down bridge br0

To show "bridge" related configurations use:

  root$ @target@/netctl/bin/netconf show bridge br0

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/bridge/br0 <<'EOF'
# Create Bridge "br0" device with STP enabled as Root bridge
bridge_br0="br0 type bridge stp_state 1 priority 0"

# Enslave it to VRF "red"
bridge_br0_ref1="@br0 master red up"

# Disable ARP responces on it (disable IPv4 unicast)
bridge_br0_ref4="net/ipv4/conf/br0/arp_ignore=8"
# Disable IPv6 on it
bridge_br0_ref6="net/ipv6/conf/br0/disable_ipv6=1"

# Alternative is to disable ARPs on interface
#bridge_br0_ref10="@br0 arp off"
EOF

See help output from below commands for more information about this
example setup:

  root$ @target@/netctl/bin/netconf help ifb
  root$ @target@/netctl/bin/netconf help vrf
  # this help message
  root$ @target@/netctl/bin/netconf help bond
  root$ @target@/netctl/bin/netconf help host
  root$ @target@/netctl/bin/netconf help vlan
  root$ @target@/netctl/bin/netconf help route

Create bridge device running in-kernel 802.1d STP implementation with lowest
possible priority (0) to increase chance being elected as Root bridge and IP
and IPv6 disabled on it.

Then bridge then enslaved to VRF device to be used to implement so called
by known network vendor "IP unnumbered" schema where each subscriber circuit
represented as network device in Linux (e.g. regular VLAN or C-TAG served on
top of S-TAG for 802.1ad (QinQ) deployments) with route specifying single
host pointed to it.

_EOF
}

##
## BOND
##

# Usage: netconf_bond_help
netconf_bond_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

BOND
====

Managing runtime configuration
------------------------------

To bring configured "bond" device (e.g. "bond0") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up bond bond0 bond1
  root$ @target@/netctl/bin/netconf down bond bond0 bond1

To show "bond" related configurations use:

  root$ @target@/netctl/bin/netconf show bond bond0 bond1

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/bond/bond0 <<'EOF'
# Create "bond0" device in 802.3ad (LACP) mode with layer2+3 hash
bond_bond0="bond0 type bond mode 802.3ad xmit_hash_policy layer2+3 miimon 100"

# Enslave "bond0" as port to bridge "br0" and set mtu to 9000 bytes
bond_bond0_ref1="@bond0 mtu 9000 master br0 type bridge_slave root_block on"
EOF

  root$ cat >@target@/netctl/etc/netconf/bond/bond1 <<'EOF'
# Create "bond1" device in 802.3ad (LACP) mode with layer2+3 hash
bond_bond1="bond1 type bond mode 802.3ad xmit_hash_policy layer2+3 miimon 100"

# Enslave "bond1" as port to bridge "br0" and set mtu to 9000 bytes
bond_bond1_ref1="@bond1 mtu 9000 master br0 type bridge_slave root_block on"
EOF

See help output from below commands for more information about this
example setup:

  root$ @target@/netctl/bin/netconf help ifb
  root$ @target@/netctl/bin/netconf help vrf
  root$ @target@/netctl/bin/netconf help bridge
  # this help message
  root$ @target@/netctl/bin/netconf help host
  root$ @target@/netctl/bin/netconf help vlan
  root$ @target@/netctl/bin/netconf help route

Create two bonding devices operating in LACP mode, enslave them to bridge "br0"
ports blocked from becoming root ports in STP state machine.

_EOF
}

##
## HOST
##

# Usage: netconf_host_help
netconf_host_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

HOST
====

Managing runtime configuration
------------------------------

To bring configured host device(s) (e.g. "en1") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up host en1 en2
  root$ @target@/netctl/bin/netconf down host en1 en2

To show "host" related configurations use:

  root$ @target@/netctl/bin/netconf show host en1 en2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/host/en1 <<'EOF'
# Move away from modern systemd names (put down to rename successfuly)
host_enp5s0f0="@enp5s0f0 down"
host_enp5s0f0_ref1="@enp5s0f0 name en1"

# Keep down to enslave to bonding successfuly
host_en1="@en1 down"

# Apply ethtool settings
host_en1_ref1="-K-en1 gro off gso off"
host_en1_ref2="--set-ring-en1 rx 1024 tx 1024"

# Enslave to bond0
host_en1_ref4="@en1 mtu 9000 master bond0"

# Bring interface up (referenced interfaces not bringed up automatically)
host_en1_ref5="@en1 up"
EOF

  root$ cat >@target@/netctl/etc/netconf/host/en2 <<'EOF'
# Move away from modern systemd names (put down to rename successfuly)
host_enp5s0f0="@enp5s0f1 down"
host_enp5s0f1_ref1="@enp5s0f1 name en2"

# Keep down to enslave to bonding successfuly
host_en2="@en2 down"

# Apply ethtool settings
host_en2_ref1="-K-en2 gro off gso off"
host_en2_ref2="--set-ring-en2 rx 1024 tx 1024"

# Enslave to bond0
host_en2_ref4="@en2 mtu 9000 master bond1"

# Bring interface up (referenced interfaces not bringed up automatically)
host_en2_ref5="@en2 up"
EOF

See help output from below commands for more information about this
example setup:

  root$ @target@/netctl/bin/netconf help ifb
  root$ @target@/netctl/bin/netconf help vrf
  root$ @target@/netctl/bin/netconf help bridge
  root$ @target@/netctl/bin/netconf help bond
  # this help message
  root$ @target@/netctl/bin/netconf help vlan
  root$ @target@/netctl/bin/netconf help route

Configure physical NICs represented in host as network devices "en1" and
"en2" with mtu 9000 bytes, disables GRO and GSO, sets RX and TX ring
sizes to 1024 and enslaves them to "bond0" and "bond0".

_EOF
}

##
## DUMMY
##

# Usage: netconf_dummy_help
netconf_dummy_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

DUMMY
=====

Managing runtime configuration
------------------------------

To bring configured "dummy" device (e.g. "lo2") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up dummy lo2 null2
  root$ @target@/netctl/bin/netconf down dummy lo2 null2

To show "dummy" related configurations use:

  root$ @target@/netctl/bin/netconf show dummy lo2 null2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/dummy/lo2 <<'EOF'
dummy_lo2="lo2 group loopback mtu 65536 type dummy"
dummy_lo2_a0="lo2:0 203.0.113.129/32"
dummy_lo2_a1="lo2:1 2001:db8::203:0:113:129/128"
EOF

  root$ cat >@target@/netctl/etc/netconf/dummy/null2 <<'EOF'
dummy_null2="null2 group sink mtu 65536 type dummy"
dummy_null2_a0="null2:0 192.168.1.1/24 broadcast +"
dummy_null2_a1="null2:1 fe80::192:168:1:1/64"
EOF

Create dummy interface name "lo2" and host scoped IP/IPv6 addresses
added to "local" routing table only and mimic loopback interface usually
configured on network equipment.

Another one is dummy interface "null2" with IP/IPv6 network addresses
assigned to make other routes use address(es) from as gateway.

Dummy network devices discard everything sent to and never receive
anything from them.

_EOF
}

##
## VETH
##

# Usage: netconf_veth_help
netconf_veth_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

VETH
====

Managing runtime configuration
------------------------------

To bring configured "veth" device(s) (e.g. "veth10a") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up veth veth10a veth10b
  root$ @target@/netctl/bin/netconf down veth veth10a veth10b

To show "veth" related configurations use:

  root$ @target@/netctl/bin/netconf show veth veth10a veth10b

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/veth/veth10a <<'EOF'
# Create interface with mtu 9000 bytes
veth_veth10a="veth10a mtu 9000 type veth peer"
# Rename peer device veth0 to veth10b, set mtu 9000 bytes and bring it up
veth_veth10b="veth10b@veth0 name veth10b mtu 9000 up"
EOF

This works around buggy veth support in iproute2 where peer network
device name cannot be set correctly.

_EOF
}

##
## GRETAP
##

# Usage: netconf_gretap_help
netconf_gretap_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

GRETAP
======

Managing runtime configuration
------------------------------

To bring configured "gretap" device(s) (e.g. "gretap1") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up gretap gretap1 gretap2
  root$ @target@/netctl/bin/netconf down gretap gretap1 gretap2

To show "gretap" related configurations use:

  root$ @target@/netctl/bin/netconf show gretap gretap1 gretap2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/gretap/gretap1 <<'EOF'
# On remote side local and remote addresses swapped
gretap_gretap1="gretap1 type gretap local 203.0.113.129 \
remote 203.0.113.130 key 1"
EOF

  root$ cat >@target@/netctl/etc/netconf/gretap/gretap2 <<'EOF'
# On remote side local and remote addresses swapped
gretap_gretap2="gretap2 type gretap local 203.0.113.129 \
remote 203.0.113.130 key 2"
EOF

This example creates two Transparent Ethernet Bridging (TEB) tunnels between
203.0.113.129 and 203.0.113.130 addresses using key to distinguish between
tunnel data.

These network devices behave as regular Ethernet network devices featuring
broadcast and multicast. Thus can be bridged, aggregated by bonding driver
or have vlans configured on top of it.

Encapsulated data contains L2 (Ethernet) header with source MAC address
from network device which is either generated automatically or assigned
by user.

_EOF
}

##
## IP6GRETAP
##

# Usage: netconf_ip6gretap_help
netconf_ip6gretap_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

IP6GRETAP
=========

Managing runtime configuration
------------------------------

To bring configured "ip6gretap" device(s) (e.g. "ip6gretap1") up/down use
following commands (copied after root$):

  root$ @target@/netctl/bin/netconf up ip6gretap ip6gretap1 ip6gretap2
  root$ @target@/netctl/bin/netconf down ip6gretap ip6gretap1 ip6gretap2

To show "ip6gretap" related configurations use:

  root$ @target@/netctl/bin/netconf show ip6gretap ip6gretap1 ip6gretap2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/ip6gretap/ip6gretap1 <<'EOF'
# On remote side local and remote addresses swapped
ip6gretap_ip6gretap1="ip6gretap1 type ip6gretap local 2001:db8::203:0:113:129 \
remote 2001:db8::203:0:113:130 key 1"
EOF

  root$ cat >@target@/netctl/etc/netconf/ip6gretap/ip6gretap2 <<'EOF'
# On remote side local and remote addresses swapped
ip6gretap_ip6gretap2="ip6gretap2 type ip6gretap local 2001:db8::203:0:113:129 \
remote 2001:db8::203:0:113:130 key 2"
EOF

This example creates two Transparent Ethernet Bridging (TEB) tunnels between
2001:db8::203:0:113:129 and 2001:db8::203:0:113:130 addresses using key to
distinguish between tunnel data.

These network devices behave as regular Ethernet network devices featuring
broadcast and multicast. Thus can be bridged, aggregated by bonding driver
or have vlans configured on top of it.

Encapsulated data contains L2 (Ethernet) header with source MAC address
from network device which is either generated automatically or assigned
by user.

_EOF
}

##
## VXLAN
##

# Usage: netconf_vxlan_help
netconf_vxlan_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

VXLAN
=====

Managing runtime configuration
------------------------------

To bring configured "vxlan" device(s) (e.g. "vxlan1") up/down use
following commands (copied after root$):

  root$ @target@/netctl/bin/netconf up vxlan vxlan1
  root$ @target@/netctl/bin/netconf down vxlan vxlan2

To show "vxlan" related configurations use:

  root$ @target@/netctl/bin/netconf show vxlan vxlan1 vxlan2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/vxlan/vxlan1 <<'EOF'
# Do VXLAN on en0 using IPv4 multicast in current broadcast domain only (ttl 1)
# using IANA standard defined port 4789.
vxlan_vxlan1="vxlan1 type vxlan id 1 local 203.0.113.129 \
group 224.0.0.1 dev en0 ttl 1 dstport 4789"
EOF

  root$ cat >@target@/netctl/etc/netconf/vxlan/vxlan2 <<'EOF'
# Do VXLAN on en0 using IPv6 multicast in current broadcast domain only (ttl 1)
# using IANA standard defined port 4789
vxlan_vxlan2="vxlan2 type vxlan id 2 local 2001:db8::203:0:113:129 \
group ff02::1 dev en0 ttl 1 dstport 4789"
EOF

This example creates two VXLAN segments 1 and 2 using IP and IPv6 as network
protocols for UDP datagrams carrying VXLAN. Both configured to use all-nodes
multicast addresses with IP header ttl/hoplimit set to 1 to ensure datagrams
never cross router boundaries.

Since Linux VXLAN implementation started before IANA standardized port number
for VXLAN it uses non-standard port 8472. Pass "dstport" explicitly to be
compatible with IANA implementations.

These network devices behave as regular Ethernet network devices featuring
broadcast and multicast. Thus can be bridged, aggregated by bonding driver
or have vlans configured on top of it.

_EOF
}

##
## VLAN
##

# Usage: netconf_vlan_help
netconf_vlan_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

VLAN
====

Managing runtime configuration
------------------------------

To bring configured "vlan" device(s) (e.g. "br0.1000.1") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up vlan \
          br0_1000 br0_1000_1 br0_1000_2 br0_1000_3
  root$ @target@/netctl/bin/netconf down vlan \
          br0_1000 br0_1000_1 br0_1000_2 br0_1000_3

To show "vlan" related configurations use:

  root$ @target@/netctl/bin/netconf show vlan \
          br0_1000 br0_1000_1 br0_1000_2 br0_1000_3

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/vlan/br0.1000 <<'EOF'
# Create S-TAG vlan on top of "br0" with egress map setting 802.1p
vlan_br0_1000="br0.1000 link br0 type vlan id 1000 egress-qos-map 0:4"

# Attach prio qdisc as root with handle fade: to reduce probability
# of collisions with Linux priority value set on frame
vlan_br0_1000_ref1="qdisc+br0.1000 root handle fade: prio"

# Attach packet fifo to default band (class)
vlan_br0_1000_ref2="qdisc+br0.1000 parent fade:1 pfifo limit 1000"

# Put everything to default band (class) resetting Linux priority
# value to one defined in vlan egress map to set 802.1p
vlan_br0_1000_ref3="filter+br0.1000 parent fade: u32 match u32 0 0 classid :1 \
action skbedit priority 0"
EOF

  root$ cat >@target@/netctl/etc/netconf/vlan/br0.1000.1 <<'EOF'
# Create C-TAG vlan 1 on top of br0.1000.
# Note that MTU is 4 bytes less due to S-TAG.
vlan_br0_1000_1="br0.1000.1 link br0.1000 mtu 8996 group downlink \
type vlan id 1"

# Reply for ARP requests when target address is configured on any
# interface (master VRF device "red" in this case) and not scope host.
vlan_br0_1000_1_ref1="net/ipv4/conf/br0.1000.1/arp_ignore=3"

# Answer only for ARP requests whose source address routes back
# via interface ARP request comes from.
vlan_br0_1000_1_ref2="net/ipv4/conf/br0.1000.1/arp_filter=1"

# Turn on Proxy ARP functionality so subscribers from different
# circuits can communicate with each other through this router.
vlan_br0_1000_1_ref3="net/ipv4/conf/br0.1000.1/proxy_arp=1"

# Attach prio qdisc as root
vlan_br0_1000_1_ref4="qdisc+br0.1000.1 root handle 1: \
htb default 0 direct_qlen 1000"

# Redirect everything that goes to device to ifb0
vlan_br0_1000_1_ref5="filter+br0.1000.1 parent 1: u32 match u32 0 0 \
classid :0 action skbedit priority 1 action mirred egress redirect dev ifb0"
EOF

  root$ cat >@target@/netctl/etc/netconf/vlan/br0.1000.2 <<'EOF'
# Create C-TAG vlan 2 on top of br0.1000.
# Note that MTU is 4 bytes less due to S-TAG.
vlan_br0_1000_2="br0.1000.2 link br0.1000 mtu 8996 group downlink \
type vlan id 2"

# Reply for ARP requests when target address is configured on any
# interface (master VRF device "red" in this case) and not scope host.
vlan_br0_1000_2_ref1="net/ipv4/conf/br0.1000.2/arp_ignore=3"

# Answer only for ARP requests whose source address routes back
# via interface ARP request comes from.
vlan_br0_1000_2_ref2="net/ipv4/conf/br0.1000.2/arp_filter=1"

# Turn on Proxy ARP functionality so subscribers from different
# circuits can communicate with each other through this router.
vlan_br0_1000_2_ref3="net/ipv4/conf/br0.1000.2/proxy_arp=1"

# Attach prio qdisc as root
vlan_br0_1000_2_ref4="qdisc+br0.1000.2 root handle 1: \
htb default 0 direct_qlen 1000"

# Redirect everything that goes to device to ifb0
vlan_br0_1000_2_ref5="filter+br0.1000.2 parent 1: u32 match u32 0 0 \
classid :0 action skbedit priority 1 action mirred egress redirect dev ifb0"
EOF

  root$ cat >@target@/netctl/etc/netconf/vlan/br0.1000.3 <<'EOF'
# Create C-TAG vlan 3 on top of br0.1000.
# Note that MTU is 4 bytes less due to S-TAG.
vlan_br0_1000_3="br0.1000.3 link br0.1000 mtu 8996 group downlink \
type vlan id 3"

# Assign /30 address on interface
vlan_br0_1000_3_a0="br0.1000.3:0 203.0.113.5/30 broadcast +"

# Reply for ARP requests when target address is configured on incoming
# interface and is in same subnet as source address.
vlan_br0_1000_3_ref1="net/ipv4/conf/br0.1000.3/arp_ignore=2"

# Answer only for ARP requests whose source address routes back
# via interface ARP request comes from.
vlan_br0_1000_3_ref2="net/ipv4/conf/br0.1000.3/arp_filter=1"
EOF

See help output from below commands for more information about this
example setup:

  root$ @target@/netctl/bin/netconf help ifb
  root$ @target@/netctl/bin/netconf help vrf
  root$ @target@/netctl/bin/netconf help bridge
  root$ @target@/netctl/bin/netconf help bond
  root$ @target@/netctl/bin/netconf help host
  # this help message
  root$ @target@/netctl/bin/netconf help route

Create 802.1q devices on top of bridge device and set 802.1p bits on S-TAG
vlan header based on Linux priority field managed by traffic control rules.

_EOF
}

##
## MACVLAN
##

# Usage: netconf_macvlan_help
netconf_macvlan_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

MACVLAN
=======

Managing runtime configuration
------------------------------

To bring configured "macvlan" device(s) (e.g. "macvlan1") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up macvlan \
          macvlan1 macvlan2
  root$ @target@/netctl/bin/netconf down macvlan \
          macvlan1 macvlan2

To show "macvlan" related configurations use:

  root$ @target@/netctl/bin/netconf show macvlan \
          macvlan1 macvlan2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/macvlan/macvlan1 <<'EOF'
# Create macvlan in mode bridge
macvlan_macvlan1="macvlan1 link br0 type macvlan mode bridge"
EOF

  root$ cat >@target@/netctl/etc/netconf/macvlan/macvlan2 <<'EOF'
# Create macvlan in mode private
macvlan_macvlan2="macvlan2 link br0 type macvlan mode private"
EOF

Create two macvlans, both linked to "br0" interface, one operates in "bridge"
and one in "private" modes.

See ip-link(8) and "ip link help macvlan" for more information about supported
modes and their description.

_EOF
}

##
## IPVLAN
##

# Usage: netconf_ipvlan_help
netconf_ipvlan_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

IPVLAN
=======

Managing runtime configuration
------------------------------

To bring configured "ipvlan" device(s) (e.g. "ipvlan1") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up ipvlan \
          ipvlan1 ipvlan2
  root$ @target@/netctl/bin/netconf down ipvlan \
          ipvlan1 ipvlan2

To show "ipvlan" related configurations use:

  root$ @target@/netctl/bin/netconf show ipvlan \
          ipvlan1 ipvlan2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/ipvlan/ipvlan1 <<'EOF'
# Create ipvlan in mode l2
ipvlan_ipvlan1="ipvlan1 link br0 type ipvlan mode l2"
EOF

  root$ cat >@target@/netctl/etc/netconf/ipvlan/ipvlan2 <<'EOF'
# Create ipvlan in mode l3
ipvlan_ipvlan2="ipvlan2 link br0 type ipvlan mode l3"
EOF

Create two ipvlans, both linked to "br0" interface, one operates in "l2"
and one in "l3" modes.

See ip-link(8) and "ip link help ipvlan" for more information about supported
modes and their description.

_EOF
}

##
## GRE
##

# Usage: netconf_gre_help
netconf_gre_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

GRE
===

Managing runtime configuration
------------------------------

To bring configured "gre" device(s) (e.g. "gre1") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up gre gre1 gre2
  root$ @target@/netctl/bin/netconf down gre gre1 gre2

To show "gre" related configurations use:

  root$ @target@/netctl/bin/netconf show gre gre1 gre2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/gre/gre1 <<'EOF'
# On remote side local and remote addresses swapped
gre_gre1="gre1 type gre local 203.0.113.129 remote 203.0.113.130 key 3"
EOF

  root$ cat >@target@/netctl/etc/netconf/gre/gre2 <<'EOF'
# On remote side local and remote addresses swapped
gre_gre2="gre2 type gre local 203.0.113.129 remote 203.0.113.130 key 4"
EOF

This example creates two Generic Routing Encapsulation (GRE) tunnels between
203.0.113.129 and 203.0.113.130 addresses using key to distinguish between
tunnel data.

These network devices are L3, encapsulating only inner IP header with payload
in compare to ip6gretap which are L2 and include Ethernet header.

_EOF
}

##
## IP6GRE
##

# Usage: netconf_ip6gre_help
netconf_ip6gre_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

IP6GRE
======

Managing runtime configuration
------------------------------

To bring configured "ip6gre" device(s) (e.g. "ip6gre1") up/down use
following commands (copied after root$):

  root$ @target@/netctl/bin/netconf up ip6gre ip6gre1 ip6gre2
  root$ @target@/netctl/bin/netconf down ip6gre ip6gre1 ip6gre2

To show "ip6gre" related configurations use:

  root$ @target@/netctl/bin/netconf show ip6gre ip6gre1 ip6gre2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/ip6gre/ip6gre1 <<'EOF'
# On remote side local and remote addresses swapped
ip6gre_ip6gre1="ip6gre1 type ip6gre local 2001:db8::203:0:113:129 \
remote 2001:db8::203:0:113:130 key 3"
EOF

  root$ cat >@target@/netctl/etc/netconf/ip6gre/ip6gre2 <<'EOF'
# On remote side local and remote addresses swapped
ip6gre_ip6gre2="ip6gre2 type ip6gre local 2001:db8::203:0:113:129 \
remote 2001:db8::203:0:113:130 key 4"
EOF

This example creates two Generic Routing Encapsulation (GRE) tunnels between
203.0.113.129 and 203.0.113.130 addresses using key to distinguish between
tunnel data.

These network devices are L3, encapsulating only inner IP header with payload
in compare to ip6gretap which are L2 and include Ethernet header.

_EOF
}

##
## NEIGHBOUR
##

# Usage: netconf_neighbour_help
netconf_neighbour_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

NEIGHBOUR
=========

Managing runtime configuration
------------------------------

To bring configured "neighbour"s (e.g. "br0_1000_1") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up neighbour br0_1000_1 br0_1000_2
  root$ @target@/netctl/bin/netconf down neighbour br0_1000_1 br0_1000_2

To show "neighbour" related configurations use:

  root$ @target@/netctl/bin/netconf show neighbour br0_1000_1 br0_1000_2

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/neighbour/br0.1000.1 <<'EOF'
# Add static ARP entry to prevent soliciting target
neighbour_br0_1000_1="br0.1000.1 203.0.113.1 lladdr 00:11:22:aa:bb:cc \
nud permanent"
EOF

  root$ cat >@target@/netctl/etc/netconf/neighbour/br0.1000.2 <<'EOF'
# Add static ARP entry to prevent soliciting target
neighbour_br0_1000_2="br0.1000.2 203.0.113.2 lladdr 00:33:44:aa:bb:cc \
nud permanent"
EOF

There is no restriction in kernel that ARP request source and solicit target
addresses should be from same subnet. This causes ARP cache entry refresh
problem when more than one address with scope above host available in
VRF/globally kernel might choose source address from different network making
solicited target to ignore ARP requests.

After cached ARP entry moved to FAILED state kernel resumes normal source
address selection resolving entry successfuly.

Side effect is that entry resolution process takes too long, invalidating
existing ARP entry causes packet loss until entry resolved successfuly again.

As one of possible workaround for this problem static ARP entries could be
used to make sure kernel never asks for ARP resolution on network.

_EOF
}

##
## ROUTE
##

netconf_route_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

ROUTE
=====

Managing runtime configuration
------------------------------

To bring configured "route"s (e.g. "red") up/down use following
commands (copied after root$):

  root$ @target@/netctl/bin/netconf up route \
          red br0_1000_1 br0_1000_2 br0_1000_3
  root$ @target@/netctl/bin/netconf down route \
          red br0_1000_1 br0_1000_2 br0_1000_3

To show "route" related configurations use:

  root$ @target@/netctl/bin/netconf show route \
          red br0_1000_1 br0_1000_2 br0_1000_3

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

 | "IP unnumbered" routes are
 |  1) Used address configured on "lo2" (or "lo0") as preferred source address
 |     for locally originated packets (e.g. ICMP errors)
 |  2) Point host specific (/32 for IPv4) routes to subscriber circuit
 |     represented as 8021q driver (vlan) served network interface
 |  3) Set route protocol to "netconf" so that software (e.g. BIRD routing
 |     daemon) can recognize it.

  root$ cat >@target@/netctl/etc/netconf/route/br0.1000.1 <<'EOF'
# Point route to subscriber circuit termination device in vrf associated table
route_br0_1000_1="203.0.113.1 dev br0.1000.1 src 203.0.113.254 \
proto netconf table 100"
EOF

  root$ cat >@target@/netctl/etc/netconf/route/br0.1000.2 <<'EOF'
# Point route to subscriber circuit termination device in vrf associated table
route_br0_1000_2="203.0.113.2 dev br0.1000.2 src 203.0.113.254 \
proto netconf table 100"
EOF

  root$ cat >@target@/netctl/etc/netconf/route/br0.1000.3 <<'EOF'
# Point route to subscriber circuit termination device in vrf associated table
route_br0_1000_3="203.0.113.8/28 dev br0.1000.3 via 203.0.113.5 \
src 203.0.113.254 proto netconf table 100"
EOF

 | Default route in VRF associated routing table to prevent normal policy
 | routing (see ip-rule(8)) lookups when no route match exists in current
 | table (VRF leak).

  root$ cat >@target@/netctl/etc/netconf/route/red <<'EOF'
# Do not perform routing lookup outside of VRF as they implemented
# as routing policy rules (see ip-rule(8) for policy routing info)
route_red="unreachable default metric 4294967295 table 100"
EOF

 | Additional routes to show capabilities using specific route type.

  root$ cat >>@target@/netctl/etc/netconf/route/red <<'EOF'

# ping -I red 203.0.113.48 would return destination unreachable (default)
# unless more specific route present in table; assigning addresses for
# "IP unnumbered" will happen from 203.0.113.0/26 block

# ping -I red 203.0.113.193 would continue on next routing policy rule
# thus leaking VRF routing table (e.g. "main" unless more specific
# policy rule matches); do not use unless known what you are doing
route_red_ref192="throw 203.0.113.192/28 table 100"

# ping -I red 203.0.113.209 would return administratively prohibited
route_red_ref208="prohibit 203.0.113.208/28 table 100"

# ping -I red 203.0.113.225 would return nothing (silently discarded)
route_red_ref224="blackhole 203.0.113.225/26 table 100"
EOF

See help output from below commands for more information about this
example setup:

  root$ @target@/netctl/bin/netconf help ifb
  root$ @target@/netctl/bin/netconf help vrf
  root$ @target@/netctl/bin/netconf help bridge
  root$ @target@/netctl/bin/netconf help bond
  root$ @target@/netctl/bin/netconf help host
  root$ @target@/netctl/bin/netconf help vlan
  # this help message

Create routes for "IP unnumbered" schema, each pointing host specific route
to interface representing subscriber termination circuit with preferred source
and route protocol ownership.

Add more routes to VRF associated routing table 100 to show network stack
capabilities available with specific route types.
_EOF
}

##
## RULE
##

netconf_rule_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

RULE
====

Managing runtime configuration
------------------------------

To bring configured "rule"s (e.g. "family_4_pref_0x7fd0") up/down use
following commands (copied after root$):

  root$ @target@/netctl/bin/netconf up rule \
          family_4_pref_0x7fd0 family_6_pref_0x7fd0
  root$ @target@/netctl/bin/netconf down rule \
          family_4_pref_0x7fd0 family_6_pref_0x7fd0

To show "rule" related configurations use:

  root$ @target@/netctl/bin/netconf show rule \
          family_4_pref_0x7fd0 family_6_pref_0x7fd0

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/rule/mgmt_4 <<'EOF'
# This is pre-VRF method to route everything from "en0" via "management" table
rule_family_4_pref_0x7fd0="-4 0x7fd0 iif en0 table management"
rule_family_4_pref_0x7fd0="-4 0x7fd0 iif lo from 192.0.2.2 table management"
EOF

  root$ cat >@target@/netctl/etc/netconf/rule/mgmt_6 <<'EOF'
# This is pre-VRF method to route everything from "en0" via "management" table
rule_family_6_pref_0x7fd0="-6 0x7fd0 iif en0 table management"
rule_family_6_pref_0x7fd0="-6 0x7fd0 iif lo from 2001:db8::192:0:2:2 \
table management
EOF

Route IP/IPv6 packets coming from "en0" interface and all replies from source
address configured on "en0" via "management" table. This is pre-VRF era
management network support and can be useful on kernels without such support.

_EOF
}

##
## USER
##

netconf_user_help()
{
	cat >&$NCTL_STDERR <<'_EOF'

USER
====

Managing runtime configuration
------------------------------

To bring configured "user"s (e.g. "WN2019052301") up/down use
following commands (copied after root$):

  root$ @target@/netctl/bin/netconf up user WN2019052301
  root$ @target@/netctl/bin/netconf down user WN2019052301

To show "user" related configurations use:

  root$ @target@/netctl/bin/netconf show user WN2019052301

Configuration files and description
-----------------------------------

Copy following command(s), excluding "root$", to command interpreter
prompt to create example configuration:

  root$ cat >@target@/netctl/etc/netconf/vlan/WN2019052301 <<'EOF'
# Note that WN2019052301 element here points to "br1"
vlan_WN2019052301="br1.1000 link br1 type vlan id 1000"
vlan_WN2019052301_ref1="br1.1000.1 link br1.1000 group downlink \
type vlan id 1000"
EOF

  root$ cat >@target@/netctl/etc/netconf/user/WN2019052301 <<'EOF'
# This overrides configuration in vlan/WN2019052301 when both "vlan" and "user"
# items (or no items at all) specified on command line
vlan_WN2019052301="br0.1000 link br0 type vlan id 1000"
vlan_WN2019052301_ref1="br0.1000.1 link br0.1000 group downlink \
type vlan id 1000"
# This is user config
route_WN2019052301="203.0.113.1/32 dev br0.1000.1 proto netconf \
src 203.0.113.254"
neighbour_WN2019052301="br0.1000.1 203.0.113.1 lladdr 00:11:22:aa:bb:cc \
nud permanent"
EOF

User configuration sourced last. This allows user to override earlier
configurations (e.g. vlan_WN2019052301 specified in vlan/ will be
overwritten by vlan_WN2019052301 from user/).

On override previous version can be seen by explicitly specifying item on
command line:

  root$ @target@/netctl/bin/netconf show user WN2019052301
  <ts>: netconf: vlan_WN2019052301="br0.1000 link br0 type vlan id 1000"
  <ts>: netconf: vlan_WN2019052301_ref1="br0.1000.1 link br0.1000 \
group downlink type vlan id 1000"
  <ts>: netconf: route_WN2019052301="203.0.113.1/32 dev br0.1000.1 \
proto netconf src 203.0.113.254"
  <ts>: netconf: neighbour_WN2019052301="br0.1000.1 203.0.113.1 \
lladdr 00:11:22:aa:bb:cc nud permanent"

  root$ @target@/netctl/bin/netconf show vlan WN2019052301
  <ts>: netconf: vlan_WN2019052301="br1.1000 link br1 type vlan id 1000"
  <ts>: netconf: vlan_WN2019052301_ref1="br1.1000.1 link br1.1000 \
group downlink type vlan id 1000"

User config can hold all items normally put to item specific directories
(e.g. vlan/ or route/) prefixed with corresponding item prefix consolidated
under single name (e.g. WN2019052301) to improve command line experience.

It is also possible to reference existing non-user variables instead of
overwriting them:

  root$ cat >@target@/netctl/etc/netconf/user/WN2019060701 <<'EOF'
## WN2019060701

# This will add vlan_br0_1000 variable name to user_WN2019060701
# list of items to configure before any other items so startup
# dependency br0.1000.1 -> br0.1000 preserved.
user_WN2019060701="vlan_br0_1000"

# Append variables names "vlan_WN2019060701" and "route_WN2019060701"
# to user_WN2019060701 variable as list of items to configure.
vlan_WN2019060701="br0.1000.1 link br0.1000 type vlan id 1"
vlan_WN2019060701_ref0="br0.1000.1:0 203.0.113.2/30 broadcast +"

route_WN2019060701="203.0.113.4/30 via 203.0.113.1 src 203.0.113.2"

# Reference neighbour entry defined outside (e.g. in neighbour/) of
# user/ to list of items to configure. Will be added after "vlan_br0_1000"
# and before "vlan_WN2019060701" and "route_WN2019060701" in variable
# "user_WN2019060701" value.
user_WN2019060701="$user_WN2019060701 neighbour_br0_1000_1"
EOF

This commonly useful in configurations where multiple users share same
circuit (e.g. C-VLAN) and multiple C-VLANs share same S-VLAN. In that
case circuit configuration is stored in vlan/ subdirectory and
referenced from user/ specific configuration file like shown above.

_EOF
}
